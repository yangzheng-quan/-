创建Java类库  在Java项目新建Java类库在类库里建Java类 将这个类放在自己指定的包下面，在使用该包里面的类中的方法需要先导入这个包（要放在第一行） 但如果在
同一个包中就不需要导入了编写完成类库后会生成一个jar文件 选择库将该文件引用到选中的库里面

访问权限   public全局都可以访问 无修饰词的可以调同包下的方法（包访问权限等级）private（私有）可以通过公共的接口来访问该修饰词修饰的方法成员或变量
（私有的数据成员公共的方法去调用）protected 包下可用 不在一个包下的子类可以引用 属于第二大范围
枚举  enum 只可以用枚举中声明的几个量 如扑克的四种花色等
构造器 即为一个类的构造方法可以带参数可以无参数
package com.company;
public class Main {
   int huaCount=0;
   String s="initial value";
   Main(int hua){//构造器
       huaCount=hua;
       System.out.println("花瓣数="+huaCount);
   }
   Main(String ss){
       s=ss;
       System.out.println("瓣数="+s);
   }
   Main(String s,int hua){
       this(hua);
       this.s=s;
       System.out.println("String s int args");
   }
   Main(){
       this("hi",47);
       System.out.println("默认构造器");
   }
void 打印(){
    System.out.println(huaCount+s);
}


    public static void main(String[] args) {
Main X=new Main();
X.打印();
    }
}
组合语法和继承语法 设计父类方法子类通过extends继承但不可赢调用父类的private修饰的成员 代码的复用（将方法写在基类中减少代码量）也可以进行方法的重写
如果一个对象有继承父类 会在子类方法调用前会自动调用父类构造器
以下为类的复用
public class Bath {
    private String s1 = "Happy", s2, s3;//定义的地方初始化
    private Soap A;
    private int i;
    private float toy;

    public Bath() {
        System.out.println("Inside Bath()");
        s3 = "B";
        toy = 5.2f;
        A = new Soap();//构造器初始化
    }

    {
        i = 10;//实例初始化
    }

    public String toString() {
        if (s2 == null) {     //延迟初始化
            s3 = "boy";
        }
        return s1+s2+s3+i+toy+A;
    }
    public static void main(String[] args){
      Bath b=new Bath();
      System.out.println(b);
    }
}
class Soap{
    private String s;
    Soap(){
        System.out.println("Soap");
        s="constructed";//在构造器中赋值
    }
    public String toString(){return s;}
}
以下是子类调用父类构造器
public class Chess extends BoardGame {
    Chess(){
        super(20);
        System.out.println("Chess 构造器");
    }
    public static void main(String[] args){
        Chess x=new Chess();

    }
}
class BoardGame extends Game{
    BoardGame(int i){
        super(i);
        System.out.println("BoardGame 构造器");

    }

}
class Game{
Game(int i){
    System.out.println("Game 构造器");
}
}
受保护的类的继承
public class orc extends Villain {
    private int orcnumber;
    public orc(String name,int orcnumber){
        super(name);
        this.orcnumber=orcnumber;
    }
    public void change(String name,int orcnumber){
        set(name);
        this.orcnumber=orcnumber;
    }
    public String toString(){
        return"orc"+orcnumber+";"+super.toString();
    }
    public  static void main(String[] args){
        orc a=new orc("zhu",12);
    }
}
class Villain{
    private String name;
    public Villain(String name){
        this.name=name;
    }
    public String toString(){
        return "my name is:"+name;
    }
    protected  void set(String nm){
        name=nm;
    }
}
向上转型
子类实例化一个父类方法中的参数即底层的父类拿到上层的子类使用
final：
  private final int i4=rand.nextInt(20);
  static final int i7=rand.nextInt(20);
  private  final Value v1=new Value(28);
  class Value{
    int i;
    public Value(int i){
        this.i=i;
    }
    被final修饰的变量不可以变的是变量的引用 但是变量的内容是可以改变的
    如上i4的值是可以被修改
    i7的不可以 v1的值也是可以通过i来改变
    被final修饰的方法不可以被重写
    被final修饰的类不可以被继承和扩张
    

